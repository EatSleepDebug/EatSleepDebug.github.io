<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Java笔记 | NicetomEetU</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="目录 字符串比较 码点和代码单元 跳出多重嵌套循环 Java中总是采用按值调用 i *= i++ + i 的结果 ⚠关于Java中protected的作用范围 Java中静态方法中为什么不能使用this、super和直接调用非静态方法 📝有n步台阶，一次只能上1步或2步，共有多少种走法 ⚠并发编程的三大特性：原子性、可见性、有序性(搬运) Java子类重写(覆盖)父类的方法必须满足的条件(搬运)">
<meta name="keywords" content="Java,Learning">
<meta property="og:type" content="article">
<meta property="og:title" content="Java笔记">
<meta property="og:url" content="http://yoursite.com/2020/12/01/Java笔记/index.html">
<meta property="og:site_name" content="NicetomEetU">
<meta property="og:description" content="目录 字符串比较 码点和代码单元 跳出多重嵌套循环 Java中总是采用按值调用 i *= i++ + i 的结果 ⚠关于Java中protected的作用范围 Java中静态方法中为什么不能使用this、super和直接调用非静态方法 📝有n步台阶，一次只能上1步或2步，共有多少种走法 ⚠并发编程的三大特性：原子性、可见性、有序性(搬运) Java子类重写(覆盖)父类的方法必须满足的条件(搬运)">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-12-01T03:35:46.177Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java笔记">
<meta name="twitter:description" content="目录 字符串比较 码点和代码单元 跳出多重嵌套循环 Java中总是采用按值调用 i *= i++ + i 的结果 ⚠关于Java中protected的作用范围 Java中静态方法中为什么不能使用this、super和直接调用非静态方法 📝有n步台阶，一次只能上1步或2步，共有多少种走法 ⚠并发编程的三大特性：原子性、可见性、有序性(搬运) Java子类重写(覆盖)父类的方法必须满足的条件(搬运)">
  
    <link rel="alternate" href="/atom.xml" title="NicetomEetU" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">NicetomEetU</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我变秃了，也变强了~</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/01/Java笔记/" class="article-date">
  <time datetime="2020-12-01T03:31:31.550Z" itemprop="datePublished">2020-12-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Learning/">Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><h3 id="0">目录</h3></h2><ul>
<li><a href="#1">字符串比较</a></li>
<li><a href="#2">码点和代码单元</a></li>
<li><a href="#3">跳出多重嵌套循环</a></li>
<li><a href="#4">Java中总是采用按值调用</a></li>
<li><a href="#5">i *= i++ + i 的结果</a></li>
<li><a href="#6">⚠关于Java中protected的作用范围</a></li>
<li><a href="#7">Java中静态方法中为什么不能使用this、super和直接调用非静态方法</a></li>
<li><a href="#8">📝有n步台阶，一次只能上1步或2步，共有多少种走法</a></li>
<li><a href="#9">⚠并发编程的三大特性：原子性、可见性、有序性(搬运)</a></li>
<li><a href="#10">Java子类重写(覆盖)父类的方法必须满足的条件(搬运)</a></li>
<li><a href="#11">String类型赋值问题</a></li>
<li><a href="#12">Java代码块和静态代码块加载顺序</a></li>
<li><a href="#-1">杂记</a></li>
</ul>
<hr>
<h1 id="字符串比较⬆-返回目录"><a href="#字符串比较⬆-返回目录" class="headerlink" title="字符串比较⬆(返回目录)"></a><h4 id="1">字符串比较<a href="#0">⬆(返回目录)</a></h4></h1><p><strong>一定不要使用 == 运算符检测两个字符串是否相等!!!</strong> 因为，Java文档中将String类对象称为是<strong>不可变的(immutable)</strong>，优点是<strong>编译器可以让字符串共享</strong>。所以，这个运算符只能够确定两个字符串是否存放再同一个位置上。当然，如果字符串再同一个位置上，他们必然相等。但是，完全有可能将内容相同的多个字符串副本放置在不同的位置上。==实际上只有字符串<strong>字面量</strong>是共享的 <strong>（在常量池中共享一块空间，实际上比较的还是地址空间是否相同）</strong>，而+或substring等操作得到的字符串并不共享。需要进行比较时需要使用<strong>equals函数</strong>或<strong>compareTo函数</strong>(函数具体用法见API)。 <strong>（java核心技术卷1[11版] p46，47）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 错误例子</span></span><br><span class="line">   String temp = <span class="string">"Hello"</span>;</span><br><span class="line">   String temp_2 = <span class="string">"Hello"</span>;</span><br><span class="line">   <span class="keyword">if</span> (temp == temp_2) &#123;</span><br><span class="line">       <span class="comment">// probably true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (temp == <span class="string">"Hello"</span>) &#123;</span><br><span class="line">   	<span class="comment">// probably true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (temp.substring(<span class="number">0</span>, <span class="number">3</span>) == <span class="string">"Hel"</span>) &#123;</span><br><span class="line">   	<span class="comment">// probably false</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//正确例子</span></span><br><span class="line">   <span class="keyword">if</span> (temp.equals(<span class="string">"Hello"</span>) &#123;</span><br><span class="line">   	<span class="comment">// true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (temp.compareTo(<span class="string">"Hello"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">// true</span></span><br><span class="line">	<span class="comment">// 使用equals更为清晰</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="码点和代码单元⬆-返回目录"><a href="#码点和代码单元⬆-返回目录" class="headerlink" title="码点和代码单元⬆(返回目录)"></a><h4 id="2">码点和代码单元<a href="#0">⬆(返回目录)</a></h4></h1><p>关于<strong>码点(Code Point)</strong> 和 <strong>代码单元</strong> <a href="https://blog.csdn.net/diehuang3426/article/details/83422309" target="_blank" rel="noopener"><strong>链接1</strong></a> <a href="https://www.jianshu.com/p/668356dd8089" target="_blank" rel="noopener"><strong>链接2</strong></a><strong>（Java核心技术卷1[11版] p48，49）</strong></p>
<blockquote>
<p><strong>代码点（Code Point）</strong>：在 Unicode 代码空间中的一个值，取值 0x0 至 0x10FFFF，代表一个字符。</p>
</blockquote>
<blockquote>
<p><strong>代码单元（Code Unit）</strong>：在具体编码形式中的最小单位。比如 UTF-16 中一个 code unit 为 16 bits，UTF-8 中一个 code unit 为 8 bits。一个 code point 可能由一个或多个 code unit(s) 表示。在 U+10000 之前的 code point 可以由一个 UTF-16 code unit 表示，U+10000 及之后的 code point 要由两个 UTF-16 code units 表示</p>
</blockquote>
<h1 id="跳出多重嵌套循环⬆-返回目录"><a href="#跳出多重嵌套循环⬆-返回目录" class="headerlink" title="跳出多重嵌套循环⬆(返回目录)"></a><h4 id="3">跳出多重嵌套循环<a href="#0">⬆(返回目录)</a></h4></h1><p>尽管Java设计者将<strong>goto</strong>作为保留字，但实际上并没有打算在语言中使用它，因为通常认为使用<strong>goto</strong>很拙劣，通常会使代码的逻辑难以阅读及维护。但是，Java提供了一种<strong>带标签的break</strong>语句，用于跳出多重嵌套循环。示例代码如下：<strong>(java核心技术卷1[11版] p75)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// set the label</span></span><br><span class="line">read_data:</span><br><span class="line"><span class="comment">// this loop statement is tagged with the label</span></span><br><span class="line"><span class="keyword">while</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// this loop is not labeled</span></span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Enter a number &gt;= 0: "</span>);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        <span class="comment">// should never happen-can't go on</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> read_data;</span><br><span class="line">            <span class="comment">// break out of read_data loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this statement is executed immediately affer the labeled break</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// check for bad situation</span></span><br><span class="line">    <span class="comment">// deal with bad situation</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// carry out normal processing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果输入有误，执行带标签的break会跳转到带标签的语句块末尾。与任何使用break语句的代码一样，然后需要检测循环是正常结束，还是由break跳出。</p>
<blockquote>
<p>事实上，可以将标签应用到任何语句，甚至可以将其应用到if语句或者块语句，如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set the label</span></span><br><span class="line">label:</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (codition) <span class="keyword">break</span> label; <span class="comment">// exits block</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jumps here when the break statement executes</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因此，如果确实希望使用goto语句，而且一个代码块恰好在你想要跳到的位置之前结束，就可以使用break语句！当然，<strong>并不提倡使用这种方式</strong>。另外需要注意，只能<strong>跳出</strong>语句块，而不能<strong>跳入</strong>语句块。</p>
</blockquote>
<h1 id="Java中总是采用按值调用⬆-返回目录"><a href="#Java中总是采用按值调用⬆-返回目录" class="headerlink" title="Java中总是采用按值调用⬆(返回目录)"></a><h4 id="4">Java中总是采用按值调用<a href="#0">⬆(返回目录)</a></h4></h1><p>Java程序设计语言总是采用<strong>按值调用</strong>。也就是说，方法得到的是所有参数值的<strong>一个副本</strong>。具体来讲，方法不能修改传递给它的任何参数变量的内容。<strong>(Java核心技术卷1[11版] p121-p124)</strong></p>
<ol>
<li><p>当传递的参数是基本数据类型时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleValue</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">3</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> percent = <span class="number">10.0</span>;</span><br><span class="line">tripleValue(percent);</span><br><span class="line"><span class="comment">// 结果x的值为30，但percent的值仍未10</span></span><br><span class="line"><span class="comment">// 因为x初始化为percent值的一个副本，但这个方法结束后，参数变量x不再使用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当传递的参数是引用对象时：（类比cpp中<strong>恶心</strong>的指针）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x, Employee y)</span> </span>&#123;</span><br><span class="line">    Employee temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java10 引入了 var 关键字来声明变量</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Employee(<span class="string">"Alice"</span>, ...);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>, ...);</span><br><span class="line">swap(a, b);</span><br><span class="line"><span class="comment">// 此时，没有卵用。在方法结束时参数变量 x 和 y 被丢弃了</span></span><br><span class="line"><span class="comment">// 原来的变量 a 和 b 仍然引用这个方法调用之前所引用的对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但是当想改变对象参数的状态时是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleSalary</span><span class="params">(Employee x)</span> </span>&#123;</span><br><span class="line">    x.raiseSalary(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">harry = <span class="keyword">new</span> Employee(...);</span><br><span class="line">tripleSalary(harry);</span><br><span class="line"><span class="comment">// 1. x 初始化为 harry值的一个副本，这里就是一个对象引用</span></span><br><span class="line"><span class="comment">// 2. raiseSalary方法应用于这个对象引用。x和 harry同时引用的那个Employee对象的工资提高了200%</span></span><br><span class="line"><span class="comment">// 3. 方法结束后，参数变量 x不再使用。当然，对象变量 harry继续引用那个工资增至3倍的员工对象</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>总结：</strong> 方法不能修改基本数据类型的参数(即数值型或布尔型)。但是，方法可以改变对象参数的状态。同时，方法不能让一个对象参数引用一个新的对象。</p>
</blockquote>
<h1 id="i-i-i-的结果⬆-返回目录"><a href="#i-i-i-的结果⬆-返回目录" class="headerlink" title="i *= i++ + i 的结果⬆(返回目录)"></a><h4 id="5">i *= i++ + i 的结果<a href="#0">⬆(返回目录)</a></h4></h1><p><a href="https://zhuanlan.zhihu.com/p/40645506" target="_blank" rel="noopener"><strong>参考资料</strong></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下代码的运算结果是：</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">2</span>;</span><br><span class="line">i *= i++ + i;</span><br><span class="line">j *= ++j + j;</span><br><span class="line">System.out.println(<span class="string">"i="</span> + i); <span class="comment">// i=10</span></span><br><span class="line">System.out.println(<span class="string">"j="</span> + j); <span class="comment">// j=12</span></span><br></pre></td></tr></table></figure></p>
<p>用javap -c 指令看一下JVM执行过程如下：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line"><span class="function">    Code:</span></span><br><span class="line"><span class="function">       0: <span class="title">iconst_2</span></span></span><br><span class="line"><span class="function">       1: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">       2: <span class="title">iconst_2</span></span></span><br><span class="line"><span class="function">       3: <span class="title">istore_2</span></span></span><br><span class="line"><span class="function">       4: <span class="title">iload_1</span></span></span><br><span class="line"><span class="function">       5: <span class="title">iload_1</span></span></span><br><span class="line"><span class="function">       6: <span class="title">iinc</span>          1, 1</span></span><br><span class="line"><span class="function">       9: <span class="title">iload_1</span></span></span><br><span class="line"><span class="function">      10: <span class="title">iadd</span></span></span><br><span class="line"><span class="function">      11: <span class="title">imul</span></span></span><br><span class="line"><span class="function">      12: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">      13: <span class="title">iload_2</span></span></span><br><span class="line"><span class="function">      14: <span class="title">iinc</span>          2, 1</span></span><br><span class="line"><span class="function">      17: <span class="title">iload_2</span></span></span><br><span class="line"><span class="function">      18: <span class="title">iload_2</span></span></span><br><span class="line"><span class="function">      19: <span class="title">iadd</span></span></span><br><span class="line"><span class="function">      20: <span class="title">imul</span></span></span><br><span class="line"><span class="function">      21: <span class="title">istore_2</span></span></span><br><span class="line"><span class="function">      ...</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><figure class="highlight plain"><figcaption><span>当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- ```istore_i```: 弹出操作数栈栈顶元素，保存到局部变量表第i个位置</span><br><span class="line">- ```iload_i```: 加载局部变量表的第i个变量到操作数栈顶</span><br><span class="line">- ```iinc i, j```: 把局部变量i,增加j</span><br><span class="line">- ```iadd```: 操作数栈中的前两个int相加，并将结果压入操作数栈顶</span><br><span class="line">- ```imul```: 操作数栈中的前两个int相乘，并将结果压入操作数栈顶</span><br><span class="line">&gt; **工作中谁这样写，多半是脑子有泡**，目的是为了面试 ，是为了给需要这个问题的人看</span><br><span class="line"></span><br><span class="line"># &lt;h4 id=&quot;6&quot;&gt;⚠关于Java中protected的作用范围[⬆(返回目录)](#0)&lt;/h4&gt;</span><br><span class="line">很多Java的书中对protected的作用范围的描述都是 **“对本包和所有子类可见”。** 实际上，描述的很准确，但是关于**子类**部分的描述过于简略。而实际情况却很复杂（**当然，出现这种复杂的情况极有可能是写代码的思路有问题，没有很好地运用Java的编程思想**），比如：在```com.parent```包中定义一个```Parent```类并声明一个```protected String str = &quot;Whatever&quot;;```，在```com.child```包中定义一个```Child```类并且继承自```Parent```类，之后在```Child```类中使用```new Parent().str```就会报一个**属性不可见**的错误。</span><br><span class="line">- 先看一个解释：</span><br><span class="line">&gt; 6.6.2 Details on protected Access</span><br><span class="line">&gt; </span><br><span class="line">&gt; A protected member or constructor of an object may be accessed from outside the package in which it is declared only by code that is responsible for the implementation of that object.</span><br><span class="line"></span><br><span class="line">这个解释其实很清楚了，但是如果思考过后还是没有很明白，看下面这个示例：</span><br><span class="line">```java</span><br><span class="line">//in Parent.java</span><br><span class="line">package parentpackage;</span><br><span class="line">public class Parent &#123;</span><br><span class="line">    protected String parentVariable = &quot;whatever&quot;; // define protected variable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// in Children.java</span><br><span class="line">package childenpackage;</span><br><span class="line">import parentpackage.Parent;</span><br><span class="line"></span><br><span class="line">class Children extends Parent &#123;</span><br><span class="line">    Children(Parent withParent )&#123;</span><br><span class="line">        System.out.println( this.parentVariable ); // works well.</span><br><span class="line">        System.out.print(withParent.parentVariable); // doesn&apos;t work</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">// It is accessible, but only to its own variable.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>总结：</strong> 对包可见很好理解，对子类可见或许解释为对子类的实例对象可见更好理解。<a href="https://stackoverflow.com/questions/3071720/why-cant-my-subclass-access-a-protected-variable-of-its-superclass-when-its-i/3071889#" target="_blank" rel="noopener"><strong>StackOverflow关于这个问题的链接</strong>(被采纳的答案中包含了出现这种问题时更好的代码设计模式)</a></p>
</blockquote>
<h1 id="Java中静态方法中为什么不能使用this、super和直接调用非静态方法⬆-返回目录"><a href="#Java中静态方法中为什么不能使用this、super和直接调用非静态方法⬆-返回目录" class="headerlink" title="Java中静态方法中为什么不能使用this、super和直接调用非静态方法⬆(返回目录)"></a><h4 id="7">Java中静态方法中为什么不能使用this、super和直接调用非静态方法<a href="#0">⬆(返回目录)</a></h4></h1><p>这个要从java的内存机制去分析，首先当你New 一个对象的时候，并不是先在堆中为对象开辟内存空间，而是先将类中的静态方法（带有static修饰的静态函数）的代码加载到一个叫做方法区的地方，然后再在堆内存中创建对象。所以说静态方法会随着类的加载而被加载。当你new一个对象时，该对象存在于对内存中，this关键字一般指该对象，但是如果没有new对象，而是通过类名调用该类的静态方法也可以。</p>
<p>程序最终都是在内存中执行，变量只有在内存中占有一席之地时才会被访问，类的静态成员（静态变量和静态方法）属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问，非静态成员（非静态变量和非静态方法）属于类的对象，所以只有在类的对象创建（实例化）的时候才会分配内存，然后通过类的对象去访问。</p>
<p>在一个类的静态成员中去访问非静态成员之所以会出错是因为在类的非静态成员不存在的时候静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。</p>
<p><strong>静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）</strong></p>
<p><strong>static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定</strong>(static修饰的变量或者方法是在编译的时候放入方法区的，是共享的；但局部变量是运行时放入栈帧中的，是线程所特有的，只有所在线程才能访问到)<br><a href="https://www.cnblogs.com/jxldjsn/p/11410329.html" target="_blank" rel="noopener">参考链接</a></p>
<h1 id="📝有n步台阶，一次只能上1步或2步，共有多少种走法⬆-返回目录"><a href="#📝有n步台阶，一次只能上1步或2步，共有多少种走法⬆-返回目录" class="headerlink" title="📝有n步台阶，一次只能上1步或2步，共有多少种走法⬆(返回目录)"></a><h4 id="8">📝有n步台阶，一次只能上1步或2步，共有多少种走法<a href="#0">⬆(返回目录)</a></h4></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">upstairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1级：1</span></span><br><span class="line"><span class="comment">    * 2级：2   1步1步  和 2步</span></span><br><span class="line"><span class="comment">    * 3级：上到1级的总走法（因为从1级上到3级直接跨2步）  + 上到2级的总走法（从2级上到3级直接跨1步）</span></span><br><span class="line"><span class="comment">    * 					因为从1级走1步就归到上到2级的走法里面了</span></span><br><span class="line"><span class="comment">    * 4级：上到2级的总走法 + 上到3级的总走法</span></span><br><span class="line"><span class="comment">    * ...</span></span><br><span class="line"><span class="comment">    * 即最后一步要么跨1步，要么跨2步</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> upstairs(n - <span class="number">1</span>) + upstairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="⚠并发编程的三大特性：原子性、可见性、有序性-搬运-⬆-返回目录"><a href="#⚠并发编程的三大特性：原子性、可见性、有序性-搬运-⬆-返回目录" class="headerlink" title="⚠并发编程的三大特性：原子性、可见性、有序性(搬运)⬆(返回目录)"></a><h4 id="9">⚠并发编程的三大特性：原子性、可见性、有序性(搬运)<a href="#0">⬆(返回目录)</a></h4></h1><p><a href="https://zhuanlan.zhihu.com/p/141744632" target="_blank" rel="noopener"><strong>文章搬运地址</strong></a> （搬运请注明原出处，我只是大自然的搬运工，原作者码字不易🍖）</p>
<p><strong>Java内存模型</strong></p>
<p>在讲三大特性之前先简单介绍一下Java内存模型（Java Memory Model，简称JMM），了解了Java内存模型以后，可以更好地理解三大特性。</p>
<p>Java内存模型是一种抽象的概念，并不是真实存在的，它描述的是一组规范或者规定。JVM运行程序的实体是线程，每一个线程都有自己私有的工作内存。Java内存模型中规定了所有变量都存储在主内存中，主内存是一块共享内存区域，所有线程都可以访问。但是线程对变量的读取赋值等操作必须在自己的工作内存中进行，在操作之前先把变量从主内存中复制到自己的工作内存中，然后对变量进行操作，操作完成后再把变量写回主内存。线程不能直接操作主内存中的变量，线程的工作内存中存放的是主内存中变量的副本。</p>
<p><strong>原子性（Atomicity）</strong></p>
<p><strong>什么是原子性</strong></p>
<p>原子性是指：在一次或者多次操作时，要么所有操作都被执行，要么所有操作都不执行。</p>
<p>一般说到原子性都会以银行转账作为例子，比如张三向李四转账100块钱，这包含了两个原子操作：在张三的账户上减少100块钱；在李四的账户上增加100块钱。这两个操作必须保证原子性的要求，要么都执行成功，要么都执行失败。不能出现张三的账户减少100块钱而李四的账户没增加100块钱，也不能出现张三的账户没减少100块钱而李四的账户却增加100块钱。</p>
<p><strong>原子性示例</strong></p>
<p><strong>示例一</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">根据上面介绍的Java内存模型，线程先把```i=1```写入工作内存中，然后再把它写入主内存，就此赋值语句可以说是具有原子性。</span><br><span class="line"></span><br><span class="line">**示例二**</span><br><span class="line"></span><br><span class="line">```i = j;</span><br></pre></td></tr></table></figure>
<p>这个赋值操作实际上包含两个步骤：线程从主内存中读取j的值，然后把它存入当前线程的工作内存中；线程把工作内存中的 i 改为 j 的值，然后把i的值写入主内存中。虽然这两个步骤都是原子性的操作，但是合在一起就不是原子性的操作。</p>
<p><strong>示例三</strong></p>
<p><strong>i++;</strong></p>
<p>这个自增操作实际上包含三个步骤：线程从主内存中读取i的值，然后把它存入当前线程的工作内存中；线程把工作内存中的i执行加1操作；线程再把i的值写入主内存中。和上一个示例一样，虽然这三个步骤都是原子性的操作，但是合在一起就不是原子性的操作。</p>
<p>从上面三个示例中，我们可以发现：简单的读取和赋值操作是原子性的，但把一个变量赋值给另一个变量就不是原子性的了；多个原子性的操作放在一起也不是原子性的。</p>
<p><strong>如何保证原子性</strong></p>
<p>在Java内存模型中，只保证了基本读取和赋值的原子性操作。如果想保证多个操作的原子性，需要使用<figure class="highlight plain"><figcaption><span>int、long 等类型的自增操作具有原子性，可以用```java.util.concurrent.atomic```包下的工具类，如：```AtomicInteger```、```AtomicLong```等。另外需要注意⚠的是，**```volatile```关键字不具有保证原子性的语义。**</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**可见性（Visibility）**</span><br><span class="line"></span><br><span class="line">**什么是可见性**</span><br><span class="line"></span><br><span class="line">可见性是指：当一个线程对共享变量进行修改后，另外一个线程可以立即看到该变量修改后的最新值。</span><br><span class="line"></span><br><span class="line">**可见性示例**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package onemore.study;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class VisibilityTest &#123;</span><br><span class="line">    public static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;);</span><br><span class="line"></span><br><span class="line">        //读取count值的线程</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;开始读取count...&quot;);</span><br><span class="line">            int i = count;//存放count的更新前的值</span><br><span class="line">            while (count &lt; 3) &#123;</span><br><span class="line">                if (count != i) &#123;//当count的值发生改变时，打印count被更新</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + &quot; count被更新为&quot; + count);</span><br><span class="line">                    i = count;//存放count的更新前的值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //更新count值的线程</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line">                //每隔1秒为count赋值一次新的值</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sdf.format(new Date()) + &quot; 赋值count为&quot; + i);</span><br><span class="line">                count = i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在运行代码之前，先想一下运行的输出是什么样子的？在更新count值的线程中，每一次更新count以后，在读取count值的线程中都会有一次输出嘛？让我们来看一下运行输出是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始读取count...</span><br><span class="line">17:21:54.796 赋值count为1</span><br><span class="line">17:21:55.798 赋值count为2</span><br><span class="line">17:21:56.799 赋值count为3</span><br></pre></td></tr></table></figure>
<p>从运行的输出看出，读取count值的线程一直没有读取到count的最新值，这是为什么呢？因为在读取count值的线程中，第一次读取count值时，从主内存中读取count的值后写入到自己的工作内存中，再从工作内存中读取，之后的读取的count值都是从自己的工作内存中读取，并没有发现更新count值的线程对count值的修改。</p>
<p><strong>如何保证可见性</strong></p>
<p>在Java中可以用以下<strong>3种</strong>方式保证可见性。</p>
<p>**使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当一个变量被```volatile```关键字修饰时，其他线程对该变量进行了修改后，会导致当前线程在工作内存中的变量副本失效，必须从主内存中再次获取，当前线程修改工作内存中的变量后，同时也会立刻将其修改刷新到主内存中。</span><br><span class="line"></span><br><span class="line">**使用```synchronized```关键字**</span><br><span class="line"></span><br><span class="line">```synchronized```关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法或者代码块，并且确保在锁释放之前，会把变量的修改刷新到主内存中。</span><br><span class="line"></span><br><span class="line">**使用```Lock```相关的工具类**</span><br><span class="line"></span><br><span class="line">```Lock```相关的工具类的```lock```方法能够保证同一时刻只有一个线程获得锁，然后执行同步代码块，并且确保执行```Lock```相关的工具类的```unlock```方法在之前，会把变量的修改刷新到主内存中。</span><br><span class="line"></span><br><span class="line">**有序性（Ordering）**</span><br><span class="line"></span><br><span class="line">**什么是有序性**</span><br><span class="line"></span><br><span class="line">有序性指的是：程序执行的顺序按照代码的先后顺序执行。</span><br><span class="line"></span><br><span class="line">在Java中，为了提高程序的运行效率，可能在编译期和运行期会对代码指令进行一定的优化，不会百分之百的保证代码的执行顺序严格按照编写代码中的顺序执行，但也不是随意进行重排序，它会保证程序的最终运算结果是编码时所期望的。这种情况被称之为**指令重排（Instruction Reordering）**。</span><br><span class="line"></span><br><span class="line">**有序性示例**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package onemore.study;</span><br><span class="line"></span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isInit = false;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (!isInit) &#123;//判断是否初始化过</span><br><span class="line">            instance = new Singleton();//初始化</span><br><span class="line">            isInit = true;//初始化标识赋值为true</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个有问题的<a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener"><strong>单例模式</strong></a>示例，假如在编译期或运行期时指令重排，把<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**如何保证有序性**</span><br><span class="line"></span><br><span class="line">这里就要提到Java内存模型的一个叫做**先行发生（Happens-Before）** 的原则了。如果两个操作的执行顺序无法从 **Happens-Before**原则推到出来，那么可以对它们进行随意的重排序处理了。**Happens-Before**原则有哪些呢？</span><br><span class="line"></span><br><span class="line">- 程序次序原则：一段代码在单线程中执行的结果是有序的。</span><br><span class="line">- 锁定原则：一个锁处于被锁定状态，那么必须先执行```unlock```操作后面才能进行```lock```操作。</span><br><span class="line">- **volatile**变量原则：同时对```volatile```变量进行读写操作，写操作一定先于读操作。</span><br><span class="line">- 线程启动原则：```Thread```对象的```start```方法先于此线程的每一个动作。</span><br><span class="line">- 线程终结原则：线程中的所有操作都先于对此线程的终止检测。</span><br><span class="line">- 线程中断原则：对线程```interrupt```方法的调用先于被中断线程的代码检测到中断事件的发生。</span><br><span class="line">- 对象终结原则：一个对象的初始化完成先于它的```finalize```方法的开始。</span><br><span class="line">- 传递原则：操作A先于操作B，操作B先于操作C，那么操作A一定先于操作C。</span><br><span class="line"></span><br><span class="line">除了**Happens-Before**原则提供的天然有序性，我们还可以用以下几种方式保证有序性：</span><br><span class="line"></span><br><span class="line">- 使用```volatile```关键字保证有序性。</span><br><span class="line">- 使用```synchronized```关键字保证有序性。</span><br><span class="line">- 使用```Lock```相关的工具类保证有序性。</span><br><span class="line"></span><br><span class="line">**总结**</span><br><span class="line"></span><br><span class="line">- 原子性：在一次或者多次操作时，要么所有操作都被执行，要么所有操作都不执行。</span><br><span class="line">- 可见性：当一个线程对共享变量进行修改后，另外一个线程可以立即看到该变量修改后的最新值。</span><br><span class="line">- 有序性：程序执行的顺序按照代码的先后顺序执行。</span><br><span class="line"></span><br><span class="line">```synchronized```关键字和```Lock```相关的工具类可以保证原子性、可见性和有序性，```volatile```关键字可以保证可见性和有序性，⚠**不能**保证原子性。</span><br><span class="line"></span><br><span class="line"># &lt;h4 id=&quot;10&quot;&gt;Java子类重写(覆盖)父类的方法必须满足的条件(搬运)[⬆(返回目录)](#0)&lt;/h4&gt;</span><br><span class="line">[**文章搬运地址**](https://www.jianshu.com/p/6ceb4c581d3b) （搬运请注明原出处，我只是大自然的搬运工，原作者码字不易🍖）</span><br><span class="line"></span><br><span class="line">1. 父类中的方法在子类中必须可见，即子类继承了父类中的该方法（可以显式的使用 super 关键字来访问父类中的被重写的方法），如果父类中的方法为```private```类型的，那么子类虽能继承，但无法覆盖</span><br><span class="line"></span><br><span class="line">2. 子类和父类的方法必须是实例方法，如果父类是```static```方法而子类是实例方法，或者相反都会报错。如果父类和子类都是```static```方法，那么子类隐藏父类的方法，而不是重写父类方法</span><br><span class="line"></span><br><span class="line">3. 子类和父类的方法必须要具有相同的函数名称、参数列表，并且子类的返回值与父类相同或者是父类返回类型的子类型（jdk1.5 之后）。如果方法名称相同而参数列表不同（返回类型可以相同也可以不同），那么只是方法的重载，而非重写。如果方法名称和参数列表相同，返回值类型不同，子类返回值类型也不是父类返回值类型的子类，编译器就会报错</span><br><span class="line"></span><br><span class="line">4. 子类方法的访问权限不能小于父类方法的访问权限（可以具有相同的访问权限或者子类的访问权限大于父类）。访问权限由高到低：```public```、```protected```、```(default)```、```private```。如果子类方法的访问权限低于父类，则编译器会给出错误信息</span><br><span class="line"></span><br><span class="line">5. 子类方法不能比父类方法抛出更多的编译时异常（不是运行时异常），即子类方法抛出的编译时异常或者和父类相同或者是父类异常的子类。当然，子类也可以不抛出异常，或者抛出```RuntimeException```异常</span><br><span class="line"></span><br><span class="line">6. 不能重写被标识为```final```的方法。```final```方法可以被继承，但不能被重写。一个方法如果被```final```修饰就意味着这个方法不会被改动</span><br><span class="line"></span><br><span class="line">- **为何子类重写方法的访问权限不能低于父类中权限**</span><br><span class="line"></span><br><span class="line">    因为向上转型及 Java 程序设计维护的原因</span><br><span class="line"></span><br><span class="line">    假设一个父类 A 拥有的方法```public void setXXX() &#123;&#125;```可以被其他任意对象调用</span><br><span class="line">    这个方法被子类 B 覆写后为```void setXXX() &#123;&#125;```即默认的访问权限只能被本包极其子类所访问</span><br><span class="line"></span><br><span class="line">    假设其他包中的对象 C 调用方法：</span><br><span class="line">    ```java</span><br><span class="line">    void get(A a) &#123;</span><br><span class="line">        a.setXXX();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>假设此时传入的对象为 B 类对象 b，此时 b 将转型为 a 但是 b 中的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **为何子类重写方法的返回类型必须与父类相同或者是父类返回类型的子类型**</span><br><span class="line"></span><br><span class="line">    也是因为向上转型</span><br><span class="line"></span><br><span class="line">    假设 B 是 A 的子类，初始化 a 为 B 类型，并调用 B 类重写过的方法``` func()：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">C aa = a.func();</span><br></pre></td></tr></table></figure>

假设原本 A 类的<figure class="highlight plain"><figcaption><span>C，那么 B 类的```func()```方法返回类型就只能是 C 类或 C 类的子类型了</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 其实，我个人认为这里这个例子举得并不是很好。换个思路，从代码复用性角度去想，假设有一个场景如下：</span><br><span class="line">```java</span><br><span class="line">A[] arr = new A()[len];</span><br><span class="line">// 添加一些A子类的对象进数组，但并不只有一种子类对象</span><br><span class="line">arr[0] = new B(); // B extends A</span><br><span class="line">arr[1] = new C(); // C extends A</span><br><span class="line">...</span><br><span class="line">for (A a : arr) &#123;</span><br><span class="line">    // do something</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

&gt; 这样就会比较方便了，如果有更好的例子或更合理的解释，欢迎留言
</code></pre><ul>
<li><p><strong>为何子类方法不能比父类方法抛出更多的编译时异常</strong></p>
<p>  子类在覆盖父类方法的时候，父类的引用可以调用该方法。如果父类的引用调用子类的方法，那么这个多抛出来的异常，就可能处于一种无法被处理的状态</p>
</li>
</ul>
<h1 id="String类型赋值问题⬆-返回目录"><a href="#String类型赋值问题⬆-返回目录" class="headerlink" title="String类型赋值问题⬆(返回目录)"></a><h4 id="11">String类型赋值问题<a href="#0">⬆(返回目录)</a></h4></h1><p>先看一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">...</span><br><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现其中有个<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">String str = &quot;aaa&quot;;</span><br><span class="line">str = &quot;bbb&quot;;</span><br></pre></td></tr></table></figure></p>
<p>有没有感觉到有什么不对，是的，好像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">String str = &quot;aaa&quot;;</span><br><span class="line">str = &quot;bbbbb&quot;;</span><br></pre></td></tr></table></figure></p>
<p>好像又不对了，这里<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是的，这里不仅仅改变了```value```的地址，连```str```其实都已经不是之前的```str```了，实际上，这里恰好体现了```String```是一个引用类型的事实，```str = &quot;bbbbb&quot;;```首先从常量池寻找是否存在```&quot;bbbbb&quot;```，如果没有就创建一个，然后返回一个```String```类型对象的副本，然后再把这个副本赋值给```str```。这个看着很像基本数据类型的赋值语句，实则是非常典型的引用类型的赋值语句。所以，用```final```修饰的```String```类型变量因无法修改其指向的地址，所以就无法修改。</span><br><span class="line">```java</span><br><span class="line">final String str = &quot;aaa&quot;;</span><br><span class="line">str = &quot;bbbbb&quot;;</span><br><span class="line">// error: Cannot assign a value to final variable &apos;str&apos;</span><br></pre></td></tr></table></figure></p>
<p><strong>但是</strong>，当使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">String str = &quot;aaa&quot;;</span><br><span class="line">System.out.println(str == &quot;aaa&quot;); // true</span><br><span class="line">System.out.println(new String(&quot;aaa&quot;) == &quot;aaa&quot;); // false</span><br><span class="line">System.out.println(new String(&quot;aaa&quot;) == str); // false</span><br></pre></td></tr></table></figure></p>
<h1 id="Java代码块和静态代码块加载顺序⬆-返回目录"><a href="#Java代码块和静态代码块加载顺序⬆-返回目录" class="headerlink" title="Java代码块和静态代码块加载顺序⬆(返回目录)"></a><h4 id="12">Java代码块和静态代码块加载顺序<a href="#0">⬆(返回目录)</a></h4></h1><p>先看如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = aaa();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String tel = bbb();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person 无参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is aaa func()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"aaa"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bbb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is bbb func()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"bbb"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this is bbb func()</span><br><span class="line">静态初始化块</span><br><span class="line">this is aaa func()</span><br><span class="line">实例初始化块</span><br><span class="line">person 无参构造</span><br></pre></td></tr></table></figure></p>
<p>再看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = aaa();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String tel = bbb();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person 无参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is aaa func()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"aaa"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bbb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is bbb func()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"bbb"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">静态初始化块</span><br><span class="line">this is bbb func()</span><br><span class="line">实例初始化块</span><br><span class="line">this is aaa func()</span><br><span class="line">person 无参构造</span><br></pre></td></tr></table></figure></p>
<p><strong>所以</strong>，静态代码块和其他静态资源在类加载时按代码顺序加载，非静态代码块和其他非静态资源在实例化时按代码顺序加载。</p>
<h1 id="杂记⬆-返回目录"><a href="#杂记⬆-返回目录" class="headerlink" title="杂记⬆(返回目录)"></a><h4 id="-1">杂记<a href="#0">⬆(返回目录)</a></h4></h1><ul>
<li>Java实际上并没有多维数组，只有一维数组。多维数组被解释为“数组的数组”。<strong>arr[i][j]</strong> 中每个<strong>arr[i]</strong> 本身也是一个数组<strong>arr[i][j]</strong> 引用这个数组的第j个元素</li>
<li>在Java中，所有链表实际上都是<strong>双向链接</strong>的——即每个链接还存放着其前驱的引用</li>
<li>在需要动态数组时，一般有两个选择<code>Vector</code>和<code>ArrayList</code>。其中，<code>Vector</code>类的所有方法都是<strong>同步的</strong>。可以安全地从两个线程访问一个<code>Vector</code>对象。但是，如果只从一个线程访问<code>Vector</code>(这种情况更为常见)，代码就会在同步操作上白白浪费大量的时间。而与之不同，<code>ArrayList</code>方法不是同步的，因此，建议在不需要同步时使用<code>ArrayList</code>，而不要使用<code>Vector</code>。</li>
<li>⚠<strong>不要</strong>调用<code>Thread</code>类或<code>Runnable</code>对象的<code>run</code>方法。直接调用<code>run</code>方法只会在<strong>同一个线程</strong>中执行这个任务——而没有启动新的线程。实际上，应当调用<code>Thread.start</code>方法，这会创建一个执行<code>run</code>方法的新线程。</li>
<li>子类构造器默认第一行是<code>super();</code>，除非在子类构造器第一行显示调用父类有参构造器<code>super(some args);</code>。抽象类也是存在构造器的，为了实例化子类对象的时候调用。</li>
<li>调用Object.hashCode()方法会采用hash算法，将对象计算出一个hash值（int型数据）。<strong>两个对象的hash值不同时，两个对象肯定不同；两个对象的hash值相同时，两个对象也不一定相同。</strong></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/12/01/Java笔记/" data-id="cki5pg8810005swvy78myjqoa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learning/">Learning</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/12/01/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Learning/">Learning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Testing/">Testing</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Another-Tag/">Another Tag</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Learning/">Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Testing/">Testing</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Another-Tag/" style="font-size: 10px;">Another Tag</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Learning/" style="font-size: 10px;">Learning</a> <a href="/tags/Testing/" style="font-size: 10px;">Testing</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/01/Java笔记/">Java笔记</a>
          </li>
        
          <li>
            <a href="/2020/12/01/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/12/01/test/">测试文章</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 东北什么大学<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>